'use client';

import React, { useState, useEffect } from 'react';
import { Button, Text, Modal, Loading, Form, ImageUploadGrid, ImageItem } from '@/components/slices';
import { Input } from '@/components/slices/Input/Input';
import { Listing } from '@/types/listing';
import { useUserListingsStore } from '@/stores/userListingsStore';
import { useUserAuthStore } from '@/stores/userAuthStore';
import { useMetadataStore } from '@/stores/metadataStore';
import { useNotificationStore } from '@/stores/notificationStore';
import { cachedGraphQLRequest } from '@/utils/graphql-cache';
import { LISTING_STATUS_LABELS, mapToOptions } from '@/constants/metadata-labels';
import { renderAttributeField } from '@/utils/attributeFieldRenderer';
import styles from './EditListingModal.module.scss';

interface EditListingModalProps {
  listing: Listing;
  onClose: () => void;
  onSave: (updatedData: Partial<Listing>) => Promise<void>;
}

interface Brand {
  id: string;
  name: string;
  slug: string;
  isActive: boolean;
}

interface Model {
  id: string;
  name: string;
  slug: string;
  isActive: boolean;
}

interface Attribute {
  key: string;
  name: string;
  label: string;
  type: string;
  validation: string;
  options?: Array<{ key: string; value: string }>;
  sortOrder: number;
  storageType: string;
}

export const EditListingModal: React.FC<EditListingModalProps> = ({
  listing,
  onClose,
  onSave,
}) => {
  const { userPackage, user } = useUserAuthStore();
  const { addNotification } = useNotificationStore();
  const [formData, setFormData] = useState({
    title: listing.title,
    description: listing.description || '',
    priceMinor: listing.priceMinor,
    status: listing.status,
    allowBidding: listing.allowBidding,
    biddingStartPrice: listing.biddingStartPrice,
    specs: {} as Record<string, any>,
    location: {
      province: '',
      city: '',
      area: '',
      link: '',
    },
  });
  const [images, setImages] = useState<ImageItem[]>([]);
  const [isUploadingImage, setIsUploadingImage] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [detailedListing, setDetailedListing] = useState<Listing | null>(null);
  const [loadingDetails, setLoadingDetails] = useState(true);
  const [attributes, setAttributes] = useState<Attribute[]>([]);
  const [brands, setBrands] = useState<Brand[]>([]);
  const [models, setModels] = useState<Model[]>([]);
  const [isLoadingBrands, setIsLoadingBrands] = useState(false);
  const [isLoadingModels, setIsLoadingModels] = useState(false);
  const { loadMyListingById } = useUserListingsStore();
  const { listingStatuses, fetchListingMetadata } = useMetadataStore();

  // Get subscription limits
  const maxImagesAllowed = userPackage?.userSubscription?.maxImagesPerListing || 5;

  // Fetch listing statuses on mount
  useEffect(() => {
    if (listingStatuses.length === 0) {
      fetchListingMetadata();
    }
  }, [listingStatuses.length, fetchListingMetadata]);

  // Fetch detailed listing data from backend
  const fetchListingDetails = async () => {
    setLoadingDetails(true);
    try {
      await loadMyListingById(listing.id);
      const currentListing = useUserListingsStore.getState().currentListing;
      setDetailedListing(currentListing);

      // Initialize images from existing listing
      if (currentListing?.images && currentListing.images.length > 0) {
        const existingImages: ImageItem[] = currentListing.images.map((img, index) => ({
          id: img.key || `existing-${index}`,
          url: img.url,
        }));
        setImages(existingImages);
        console.log('ğŸ–¼ï¸ Loaded images:', existingImages);
      } else if (currentListing?.imageKeys && currentListing.imageKeys.length > 0) {
        // Fallback: If images array is empty but imageKeys exist, build URLs from keys
        const existingImages: ImageItem[] = currentListing.imageKeys.map((key, index) => ({
          id: key,
          url: `https://imagedelivery.net/${process.env.NEXT_PUBLIC_CLOUDFLARE_ACCOUNT_HASH}/${key}/public`,
        }));
        setImages(existingImages);
        console.log('ğŸ–¼ï¸ Built images from keys:', existingImages);
      }

      // Initialize specs and location from listing
      if (currentListing?.specs) {
        setFormData(prev => ({
          ...prev,
          specs: currentListing.specs || {},
        }));
      }

      if (currentListing?.location) {
        setFormData(prev => ({
          ...prev,
          location: currentListing.location || { province: '', city: '', area: '', link: '' },
        }));
      }
    } catch (error) {
      console.error('Failed to fetch listing details:', error);
      // Fallback to basic listing data if API fails
      setDetailedListing(listing);
    } finally {
      setLoadingDetails(false);
    }
  };

  useEffect(() => {
    fetchListingDetails();
  }, [listing.id]);

  // Fetch attributes for the category
  useEffect(() => {
    const fetchAttributes = async () => {
      if (!listing.category?.id) return;

      try {
        const data = await cachedGraphQLRequest(
          `query GetAttributesByCategory($categoryId: String!) {
            getAttributesByCategory(categoryId: $categoryId) {
              key
              name
              label
              type
              validation
              options { key value }
              sortOrder
              storageType
            }
          }`,
          { categoryId: listing.category.id }
        );
        setAttributes((data as any).getAttributesByCategory || []);
      } catch (error) {
        console.error('Error fetching attributes:', error);
      }
    };

    fetchAttributes();
  }, [listing.category?.id]);

  // Fetch brands when category is available
  useEffect(() => {
    const fetchBrands = async () => {
      if (!listing.category?.id) return;

      setIsLoadingBrands(true);
      try {
        const data = await cachedGraphQLRequest(
          `query GetBrands($categoryId: String!) {
            brands(categoryId: $categoryId) {
              id
              name
              slug
              isActive
            }
          }`,
          { categoryId: listing.category.id }
        );
        setBrands((data as any).brands || []);
      } catch (error) {
        console.error('Error fetching brands:', error);
      } finally {
        setIsLoadingBrands(false);
      }
    };

    fetchBrands();
  }, [listing.category?.id]);

  // Fetch models when brand is selected
  useEffect(() => {
    const fetchModels = async () => {
      const brandId = formData.specs.brandId;
      if (!brandId || brandId.startsWith('temp_')) {
        setModels([]);
        return;
      }

      setIsLoadingModels(true);
      try {
        const data = await cachedGraphQLRequest(
          `query GetModels($brandId: String!) {
            models(brandId: $brandId) {
              id
              name
              slug
              isActive
            }
          }`,
          { brandId }
        );
        setModels((data as any).models || []);
      } catch (error) {
        console.error('Error fetching models:', error);
      } finally {
        setIsLoadingModels(false);
      }
    };

    fetchModels();
  }, [formData.specs.brandId]);

  // Handle direct image upload to Cloudflare (immediately when added)
  const handleImageAdd = async (newImages: ImageItem[]) => {
    // Find newly added images (ones with file property)
    const addedImages = newImages.filter(img => img.file && !images.find(i => i.id === img.id));

    if (addedImages.length === 0) {
      setImages(newImages);
      return;
    }

    // Check subscription limits
    if (images.length + addedImages.length > maxImagesAllowed) {
      addNotification({
        type: 'error',
        title: 'ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­',
        message: `Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„ØµÙˆØ± Ù‡Ùˆ ${maxImagesAllowed} ØµÙˆØ± Ø­Ø³Ø¨ Ø§Ø´ØªØ±Ø§ÙƒÙƒ`,
        duration: 5000,
      });
      return;
    }

    setIsUploadingImage(true);
    setImages(newImages); // Optimistically update UI

    try {
      const uploadedImageKeys: string[] = [];

      for (const imageItem of addedImages) {
        if (!imageItem.file) continue;

        // Step 1: Get Cloudflare upload URL
        const uploadData = await cachedGraphQLRequest(
          `mutation { createImageUploadUrl { uploadUrl assetKey } }`,
          {},
          user?.token
        );
        const { uploadUrl } = (uploadData as any).createImageUploadUrl;

        // Step 2: Upload to Cloudflare
        const formDataUpload = new FormData();
        formDataUpload.append('file', imageItem.file);

        const uploadResponse = await fetch(uploadUrl, {
          method: 'POST',
          body: formDataUpload,
        });

        if (!uploadResponse.ok) {
          throw new Error('ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ Cloudflare');
        }

        const cloudflareResult = await uploadResponse.json();
        const realImageId = cloudflareResult?.result?.id;

        if (!realImageId) {
          throw new Error('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ø±Ù Ø§Ù„ØµÙˆØ±Ø©');
        }

        uploadedImageKeys.push(realImageId);
      }

      // Step 3: Update listing with new image keys
      const allImageKeys = [
        ...images.filter(img => !img.file).map(img => img.id),
        ...uploadedImageKeys,
      ];

      await cachedGraphQLRequest(
        `mutation UpdateListingImages($id: String!, $imageKeys: [String!]!) {
          updateMyListing(id: $id, input: { imageKeys: $imageKeys }) {
            id
          }
        }`,
        { id: listing.id, imageKeys: allImageKeys },
        user?.token
      );

      // Update local state with Cloudflare IDs
      setImages(prevImages =>
        prevImages.map(img => {
          if (img.file) {
            const index = addedImages.findIndex(a => a.id === img.id);
            if (index !== -1) {
              return { ...img, id: uploadedImageKeys[index], file: undefined };
            }
          }
          return img;
        })
      );

      addNotification({
        type: 'success',
        title: 'ØªÙ… Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±',
        message: `ØªÙ… Ø±ÙØ¹ ${uploadedImageKeys.length} ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­`,
        duration: 3000,
      });
    } catch (error) {
      console.error('Image upload error:', error);
      addNotification({
        type: 'error',
        title: 'Ø®Ø·Ø£',
        message: error instanceof Error ? error.message : 'ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±',
        duration: 5000,
      });
      // Revert optimistic update
      setImages(images);
    } finally {
      setIsUploadingImage(false);
    }
  };

  // Handle direct image delete from Cloudflare (immediately when removed)
  const handleImageDelete = async (deletedImages: ImageItem[]) => {
    const imagesToDelete = images.filter(img => !deletedImages.find(d => d.id === img.id));

    if (imagesToDelete.length === 0) {
      setImages(deletedImages);
      return;
    }

    setIsUploadingImage(true);
    setImages(deletedImages); // Optimistically update UI

    try {
      // Update listing with remaining image keys
      const remainingImageKeys = deletedImages.map(img => img.id);

      await cachedGraphQLRequest(
        `mutation UpdateListingImages($id: String!, $imageKeys: [String!]!) {
          updateMyListing(id: $id, input: { imageKeys: $imageKeys }) {
            id
          }
        }`,
        { id: listing.id, imageKeys: remainingImageKeys },
        user?.token
      );

      addNotification({
        type: 'success',
        title: 'ØªÙ… Ø­Ø°Ù Ø§Ù„ØµÙˆØ±Ø©',
        message: 'ØªÙ… Ø­Ø°Ù Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­',
        duration: 3000,
      });
    } catch (error) {
      console.error('Image delete error:', error);
      addNotification({
        type: 'error',
        title: 'Ø®Ø·Ø£',
        message: 'ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„ØµÙˆØ±Ø©',
        duration: 5000,
      });
      // Revert optimistic update
      setImages(images);
    } finally {
      setIsUploadingImage(false);
    }
  };

  // Handle creating a new brand
  const handleCreateBrand = (brandName: string) => {
    const tempBrand: Brand = {
      id: `temp_${brandName}`,
      name: brandName,
      slug: brandName.toLowerCase().replace(/\s+/g, '-'),
      isActive: true,
    };

    setBrands(prev => [...prev, tempBrand]);
    setFormData(prev => ({
      ...prev,
      specs: {
        ...prev.specs,
        brandId: tempBrand.id,
        _brandName: brandName,
      },
    }));
  };

  // Handle creating a new model
  const handleCreateModel = (modelName: string) => {
    const tempModel: Model = {
      id: `temp_${modelName}`,
      name: modelName,
      slug: modelName.toLowerCase().replace(/\s+/g, '-'),
      isActive: true,
    };

    setModels(prev => [...prev, tempModel]);
    setFormData(prev => ({
      ...prev,
      specs: {
        ...prev.specs,
        modelId: tempModel.id,
        _modelName: modelName,
      },
    }));
  };

  // Handle form submission (for form fields only, images already handled)
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    // Basic validation
    if (!formData.title.trim()) {
      setError('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†');
      return;
    }

    if (formData.priceMinor <= 0) {
      setError('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø³Ø¹Ø± ØµØ­ÙŠØ­');
      return;
    }

    setIsSubmitting(true);
    try {
      // Extract brand/model names from specs
      const brandName = formData.specs._brandName || undefined;
      const modelName = formData.specs._modelName || undefined;

      // Build clean specs object
      const specs = { ...formData.specs };
      delete specs._brandName;
      delete specs._modelName;
      if (specs.brandId?.startsWith('temp_')) delete specs.brandId;
      if (specs.modelId?.startsWith('temp_')) delete specs.modelId;

      await onSave({
        title: formData.title,
        description: formData.description,
        priceMinor: Math.round(formData.priceMinor),
        status: formData.status,
        allowBidding: formData.allowBidding,
        biddingStartPrice: formData.biddingStartPrice ? Math.round(formData.biddingStartPrice) : undefined,
        specs,
        location: formData.location,
        brandName,
        modelName,
      } as any);
    } catch (err) {
      console.error('Save error:', err);
      setError(err instanceof Error ? err.message : 'ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª');
    } finally {
      setIsSubmitting(false);
    }
  };

  // Format price - using English numbers to match user-facing listings
  const formatPrice = (priceMinor: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0
    }).format(priceMinor / 100);
  };

  // Format date - using English dates for consistency
  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US');
  };

  return (
    <Modal isVisible onClose={onClose} title="ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†" maxWidth="lg">
      {loadingDetails ? (
        <div className={styles.loadingContainer}>
          <Loading />
          <Text variant="paragraph" className={styles.loadingText}>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†...</Text>
        </div>
      ) : (
        <Form onSubmit={handleSubmit} error={error || undefined}>
          {/* Listing Header */}
          {detailedListing && (
            <div className={styles.listingHeader}>
              <Text variant="h3" className={styles.listingTitle}>{detailedListing.title}</Text>
              <div className={styles.listingInfo}>
                <div className={styles.infoItem}>
                  <span className={styles.label}>Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ</span>
                  <span className={`${styles.value} ${styles.price}`}>{formatPrice(detailedListing.priceMinor)}</span>
                </div>
                <div className={styles.infoItem}>
                  <span className={styles.label}>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡</span>
                  <span className={styles.value}>{formatDate(detailedListing.createdAt)}</span>
                </div>
                {detailedListing.updatedAt !== detailedListing.createdAt && (
                  <div className={styles.infoItem}>
                    <span className={styles.label}>Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«</span>
                    <span className={styles.value}>{formatDate(detailedListing.updatedAt)}</span>
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Image Upload Grid */}
          <div className={styles.imagesSection}>
            <Text variant="h4" className={styles.specificationsTitle}>
              Ø§Ù„ØµÙˆØ± ({images.length}/{maxImagesAllowed})
            </Text>
            <ImageUploadGrid
              images={images}
              onChange={(newImages) => {
                // Detect if images were added or removed
                if (newImages.length > images.length) {
                  handleImageAdd(newImages);
                } else if (newImages.length < images.length) {
                  handleImageDelete(newImages);
                } else {
                  setImages(newImages);
                }
              }}
              maxImages={maxImagesAllowed}
              disabled={isSubmitting || isUploadingImage}
            />
            {isUploadingImage && (
              <Text variant="small" style={{ marginTop: '8px', color: 'var(--primary)' }}>
                Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±...
              </Text>
            )}
          </div>

          {/* Editable Fields */}
          <div className={styles.editSection}>
          <Text variant="h4" className={styles.sectionTitle}>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†</Text>

          {/* Title */}
          <Input
            type="text"
            label="Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† *"
            placeholder="Ø£Ø¯Ø®Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†"
            value={formData.title}
            onChange={(e) => setFormData({ ...formData, title: e.target.value })}
            required
          />

          {/* Description */}
          <Input
            type="textarea"
            label="Ø§Ù„ÙˆØµÙ"
            placeholder="Ø£Ø¯Ø®Ù„ ÙˆØµÙ ØªÙØµÙŠÙ„ÙŠ Ù„Ù„Ø¥Ø¹Ù„Ø§Ù†"
            value={formData.description}
            onChange={(e) => setFormData({ ...formData, description: e.target.value })}
            rows={5}
          />

          {/* Price */}
          <Input
            type="number"
            label="Ø§Ù„Ø³Ø¹Ø± (Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±) *"
            placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ø³Ø¹Ø±"
            value={Math.round(formData.priceMinor / 100)}
            onChange={(e) => setFormData({ ...formData, priceMinor: parseFloat(e.target.value || '0') * 100 })}
            required
            min={0}
            step={1}
          />

          {/* Status */}
          <Input
            type="select"
            label="Ø­Ø§Ù„Ø© Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† *"
            value={formData.status}
            onChange={(e) => setFormData({ ...formData, status: e.target.value as any })}
            options={mapToOptions(listingStatuses, LISTING_STATUS_LABELS)}
            required
          />

          {/* Bidding Options */}
          <div className={styles.biddingSection}>
            <label className={styles.checkboxLabel}>
              <input
                type="checkbox"
                checked={formData.allowBidding}
                onChange={(e) => setFormData({ ...formData, allowBidding: e.target.checked })}
              />
              <span>Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ù…Ø²Ø§ÙŠØ¯Ø© Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†</span>
            </label>

            {formData.allowBidding && (
              <Input
                type="number"
                label="Ø³Ø¹Ø± Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ù„Ù„Ù…Ø²Ø§ÙŠØ¯Ø© (Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±)"
                placeholder="Ø£Ø¯Ø®Ù„ Ø³Ø¹Ø± Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©"
                value={formData.biddingStartPrice ? Math.round(formData.biddingStartPrice / 100) : ''}
                onChange={(e) => setFormData({
                  ...formData,
                  biddingStartPrice: e.target.value ? parseFloat(e.target.value || '0') * 100 : undefined
                })}
                min={0}
                step={1}
              />
            )}
          </div>
          </div>

          {/* Brand & Model Section */}
          {brands.length > 0 && (
          <div className={styles.editSection}>
            <Text variant="h4" className={styles.sectionTitle}>Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ÙˆØ§Ù„Ù…ÙˆØ¯ÙŠÙ„</Text>

            <div className={styles.formRow}>
              {/* Brand Selector */}
              <Input
                type="select"
                label="Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©"
                value={formData.specs.brandId || ''}
                onChange={(e) => {
                  setFormData(prev => ({
                    ...prev,
                    specs: {
                      ...prev.specs,
                      brandId: e.target.value,
                      modelId: '', // Clear model when brand changes
                    },
                  }));
                }}
                options={[
                  { value: '', label: '-- Ø§Ø®ØªØ± Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© --' },
                  ...brands
                    .filter(b => b.isActive)
                    .map(brand => ({
                      value: brand.id,
                      label: brand.name,
                    })),
                ]}
                disabled={isLoadingBrands}
                searchable
                creatable
                isLoading={isLoadingBrands}
                onCreateOption={handleCreateBrand}
              />

              {/* Model Selector (appears after brand is selected) */}
              {formData.specs.brandId && (
                <Input
                  type="select"
                  label="Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„"
                  value={formData.specs.modelId || ''}
                  onChange={(e) => {
                    setFormData(prev => ({
                      ...prev,
                      specs: {
                        ...prev.specs,
                        modelId: e.target.value,
                      },
                    }));
                  }}
                  options={[
                    { value: '', label: '-- Ø§Ø®ØªØ± Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ --' },
                    ...models
                      .filter(m => m.isActive)
                      .map(model => ({
                        value: model.id,
                        label: model.name,
                      })),
                  ]}
                  disabled={isLoadingModels}
                  searchable
                  creatable
                  isLoading={isLoadingModels}
                  onCreateOption={handleCreateModel}
                />
              )}
            </div>
          </div>
          )}

          {/* Other Specifications */}
          {attributes.filter(attr => attr.storageType === 'specs' && attr.key !== 'brandId' && attr.key !== 'modelId').length > 0 && (
          <div className={styles.editSection}>
            <Text variant="h4" className={styles.sectionTitle}>Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª Ø§Ù„ØªÙ‚Ù†ÙŠØ©</Text>

            <div className={styles.specsGrid}>
              {attributes
                .filter(attr => attr.storageType === 'specs' && attr.key !== 'brandId' && attr.key !== 'modelId')
                .sort((a, b) => a.sortOrder - b.sortOrder)
                .map(attribute => (
                  <div key={attribute.key}>
                    {renderAttributeField({
                      attribute,
                      value: formData.specs[attribute.key],
                      onChange: (value) => {
                        setFormData(prev => ({
                          ...prev,
                          specs: {
                            ...prev.specs,
                            [attribute.key]: value,
                          },
                        }));
                      },
                    })}
                  </div>
                ))}
            </div>
          </div>
          )}

          {/* Location Section */}
          {attributes.filter(attr => attr.storageType === 'location').length > 0 && (
          <div className={styles.editSection}>
            <Text variant="h4" className={styles.sectionTitle}>Ø§Ù„Ù…ÙˆÙ‚Ø¹</Text>

            <div className={styles.formRow}>
              {attributes
                .filter(attr => attr.storageType === 'location')
                .sort((a, b) => a.sortOrder - b.sortOrder)
                .map(attribute => (
                  <div key={attribute.key}>
                    {renderAttributeField({
                      attribute,
                      value: formData.location[attribute.key as keyof typeof formData.location],
                      onChange: (value) => {
                        setFormData(prev => ({
                          ...prev,
                          location: {
                            ...prev.location,
                            [attribute.key]: value,
                          },
                        }));
                      },
                    })}
                  </div>
                ))}
            </div>
          </div>
          )}

          <div className={styles.formActions}>
            <Button
              type="button"
              onClick={onClose}
              variant="outline"
              disabled={isSubmitting}
            >
              Ø¥Ù„ØºØ§Ø¡
            </Button>
            <Button
              type="submit"
              variant="primary"
              disabled={isSubmitting}
              loading={isSubmitting}
            >
              {isSubmitting ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...' : 'Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª'}
            </Button>
          </div>
        </Form>
      )}
    </Modal>
  );
};
